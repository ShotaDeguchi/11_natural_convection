"""
********************************************************************************
operators
********************************************************************************
"""

import numpy as np

def advection(u, v, w, f, dx, dy, dz, dt, scheme="KK"):
    """
    advect f with advection rate u, v
    """
    if scheme == "1st":
        # 1st order derivatives
        f_x = (f[3:-1, 2:-2, 2:-2] - f[1:-3, 2:-2, 2:-2]) / (2. * dx)
        f_y = (f[2:-2, 3:-1, 2:-2] - f[2:-2, 1:-3, 2:-2]) / (2. * dy)
        f_z = (f[2:-2, 2:-2, 3:-1] - f[2:-2, 2:-2, 1:-3]) / (2. * dz)

        # 2nd order derivatives
        f_xx = (f[3:-1, 2:-2, 2:-2] - 2. * f[2:-2, 2:-2, 2:-2] + f[1:-3, 2:-2, 2:-2]) / dx**2
        f_yy = (f[2:-2, 3:-1, 2:-2] - 2. * f[2:-2, 2:-2, 2:-2] + f[2:-2, 1:-3, 2:-2]) / dy**2
        f_zz = (f[2:-2, 2:-2, 3:-1] - 2. * f[2:-2, 2:-2, 2:-2] + f[2:-2, 2:-2, 1:-3]) / dz**2

        # advection
        advc = (u[2:-2, 2:-2, 2:-2] * f_x - np.abs(u[2:-2, 2:-2, 2:-2]) * dx / 2. * f_xx) \
                + (v[2:-2, 2:-2, 2:-2] * f_y - np.abs(v[2:-2, 2:-2, 2:-2]) * dy / 2. * f_yy) \
                + (w[2:-2, 2:-2, 2:-2] * f_z - np.abs(w[2:-2, 2:-2, 2:-2]) * dz / 2. * f_zz)

    elif scheme == "LW":
        # 1st order derivatives
        f_x = (f[3:-1, 2:-2, 2:-2] - f[1:-3, 2:-2, 2:-2]) / (2. * dx)
        f_y = (f[2:-2, 3:-1, 2:-2] - f[2:-2, 1:-3, 2:-2]) / (2. * dy)
        f_z = (f[2:-2, 2:-2, 3:-1] - f[2:-2, 2:-2, 1:-3]) / (2. * dz)

        # 2nd order derivatives
        f_xx = (f[3:-1, 2:-2, 2:-2] - 2. * f[2:-2, 2:-2, 2:-2] + f[1:-3, 2:-2, 2:-2]) / dx**2
        f_yy = (f[2:-2, 3:-1, 2:-2] - 2. * f[2:-2, 2:-2, 2:-2] + f[2:-2, 1:-3, 2:-2]) / dy**2
        f_zz = (f[2:-2, 2:-2, 3:-1] - 2. * f[2:-2, 2:-2, 2:-2] + f[2:-2, 2:-2, 1:-3]) / dz**2

        # advection
        advc = (u[2:-2, 2:-2, 2:-2] * f_x - np.abs(u[2:-2, 2:-2, 2:-2])**2 * dt / 2. * f_xx) \
                + (v[2:-2, 2:-2, 2:-2] * f_y - np.abs(v[2:-2, 2:-2, 2:-2])**2 * dt / 2. * f_yy) \
                + (w[2:-2, 2:-2, 2:-2] * f_z - np.abs(w[2:-2, 2:-2, 2:-2])**2 * dt / 2. * f_zz)

    elif scheme == "QUICK":
        # 1st order derivatives
        f_x = (- f[4:, 2:-2, 2:-2] + 10. * f[3:-1, 2:-2, 2:-2] - 10. * f[1:-3, 2:-2, 2:-2] + f[:-4, 2:-2, 2:-2]) / (16. * dx)
        f_y = (- f[2:-2, 4:, 2:-2] + 10. * f[2:-2, 3:-1, 2:-2] - 10. * f[2:-2, 1:-3, 2:-2] + f[2:-2, :-4, 2:-2]) / (16. * dy)
        f_z = (- f[2:-2, 2:-2, 4:] + 10. * f[2:-2, 2:-2, 3:-1] - 10. * f[2:-2, 2:-2, 1:-3] + f[2:-2, 2:-2, :-4]) / (16. * dz)

        # 4th order derivatives
        f_xxxx = (- f[4:, 2:-2, 2:-2] + 4. * f[3:-1, 2:-2, 2:-2] - 6. * f[2:-2, 2:-2, 2:-2] + 4. * f[1:-3, 2:-2, 2:-2] - f[:-4, 2:-2, 2:-2]) / dx**4
        f_yyyy = (- f[2:-2, 4:, 2:-2] + 4. * f[2:-2, 3:-1, 2:-2] - 6. * f[2:-2, 2:-2, 2:-2] + 4. * f[2:-2, 1:-3, 2:-2] - f[2:-2, :-4, 2:-2]) / dy**4
        f_zzzz = (- f[2:-2, 2:-2, 4:] + 4. * f[2:-2, 2:-2, 3:-1] - 6. * f[2:-2, 2:-2, 2:-2] + 4. * f[2:-2, 2:-2, 1:-3] - f[2:-2, 2:-2, :-4]) / dz**4

        # advection
        advc = (u[2:-2, 2:-2, 2:-2] * f_x - np.abs(u[2:-2, 2:-2, 2:-2]) * dx**3 / 16. * f_xxxx) \
                + (v[2:-2, 2:-2, 2:-2] * f_y - np.abs(v[2:-2, 2:-2, 2:-2]) * dy**3 / 16. * f_yyyy) \
                + (w[2:-2, 2:-2, 2:-2] * f_z - np.abs(w[2:-2, 2:-2, 2:-2]) * dz**3 / 16. * f_zzzz)

    elif scheme == "QUICKEST":
        raise NotImplementedError

    elif scheme == "KK":
        # 1st order derivatives
        f_x = (- f[4:, 2:-2, 2:-2] + 8. * f[3:-1, 2:-2, 2:-2] - 8. * f[1:-3, 2:-2, 2:-2] + f[:-4, 2:-2, 2:-2]) / (12. * dx)
        f_y = (- f[2:-2, 4:, 2:-2] + 8. * f[2:-2, 3:-1, 2:-2] - 8. * f[2:-2, 1:-3, 2:-2] + f[2:-2, :-4, 2:-2]) / (12. * dy)
        f_z = (- f[2:-2, 2:-2, 4:] + 8. * f[2:-2, 2:-2, 3:-1] - 8. * f[2:-2, 2:-2, 1:-3] + f[2:-2, 2:-2, :-4]) / (12. * dz)

        # 4th order derivatives
        f_xxxx = (f[4:, 2:-2, 2:-2] - 4. * f[3:-1, 2:-2, 2:-2] + 6. * f[2:-2, 2:-2, 2:-2] - 4. * f[1:-3, 2:-2, 2:-2] + f[:-4, 2:-2, 2:-2]) / dx**4
        f_yyyy = (f[2:-2, 4:, 2:-2] - 4. * f[2:-2, 3:-1, 2:-2] + 6. * f[2:-2, 2:-2, 2:-2] - 4. * f[2:-2, 1:-3, 2:-2] + f[2:-2, :-4, 2:-2]) / dy**4
        f_zzzz = (f[2:-2, 2:-2, 4:] - 4. * f[2:-2, 2:-2, 3:-1] + 6. * f[2:-2, 2:-2, 2:-2] - 4. * f[2:-2, 2:-2, 1:-3] + f[2:-2, 2:-2, :-4]) / dz**4

        # advection
        advc = (u[2:-2, 2:-2, 2:-2] * f_x + np.abs(u[2:-2, 2:-2, 2:-2]) * dx**3 / 4. * f_xxxx) \
                + (v[2:-2, 2:-2, 2:-2] * f_y + np.abs(v[2:-2, 2:-2, 2:-2]) * dy**3 / 4. * f_yyyy) \
                + (w[2:-2, 2:-2, 2:-2] * f_z + np.abs(w[2:-2, 2:-2, 2:-2]) * dz**3 / 4. * f_zzzz)

    return advc


def diffusion(nu, f, dx, dy, dz):
    """
    diffuse f with diffusion rate nu
    """

    f_xx = (f[3:-1, 2:-2, 2:-2] - 2. * f[2:-2, 2:-2, 2:-2] + f[1:-3, 2:-2, 2:-2]) / dx**2
    f_yy = (f[2:-2, 3:-1, 2:-2] - 2. * f[2:-2, 2:-2, 2:-2] + f[2:-2, 1:-3, 2:-2]) / dy**2
    f_zz = (f[2:-2, 2:-2, 3:-1] - 2. * f[2:-2, 2:-2, 2:-2] + f[2:-2, 2:-2, 1:-3]) / dz**2

    lap = f_xx + f_yy + f_zz
    diff = nu * lap

    return diff


def velocity_divergence(u, v, w, dx, dy, dz):
    """
    velocity divergence
    evaluate at cell
    """
    u_x = 1. / 4. * (
        (u[2:-1, 1:-2, 1:-2] - u[1:-2, 1:-2, 1:-2]) / dx \
        + (u[2:-1, 2:-1, 1:-2] - u[1:-2, 2:-1, 1:-2]) / dx \
        + (u[2:-1, 1:-2, 2:-1] - u[1:-2, 1:-2, 2:-1]) / dx \
        + (u[2:-1, 2:-1, 2:-1] - u[1:-2, 2:-1, 2:-1]) / dx
    )
    v_y = 1. / 4. * (
        (v[1:-2, 2:-1, 1:-2] - v[1:-2, 1:-2, 1:-2]) / dy \
        + (v[2:-1, 2:-1, 1:-2] - v[2:-1, 1:-2, 1:-2]) / dy \
        + (v[1:-2, 2:-1, 2:-1] - v[1:-2, 1:-2, 2:-1]) / dy \
        + (v[2:-1, 2:-1, 2:-1] - v[2:-1, 1:-2, 2:-1]) / dy
    )
    w_z = 1. / 4. * (
        (w[1:-2, 1:-2, 2:-1] - w[1:-2, 1:-2, 1:-2]) / dz \
        + (w[2:-1, 1:-2, 2:-1] - w[2:-1, 1:-2, 1:-2]) / dz \
        + (w[1:-2, 2:-1, 2:-1] - w[1:-2, 2:-1, 1:-2]) / dz \
        + (w[2:-1, 2:-1, 2:-1] - w[2:-1, 2:-1, 1:-2]) / dz
    )
    div = u_x + v_y + w_z   # divergence mapped to cell center
    return div


def pressure_gradient(p, dx, dy, dz):
    """
    pressure gradient
    evaluate at vertex
    """
    p_x = 1. / 4. * (
        (p[2:-1, 1:-2, 1:-2] - p[1:-2, 1:-2, 1:-2]) / dx \
        + (p[2:-1, 2:-1, 1:-2] - p[1:-2, 2:-1, 1:-2]) / dx \
        + (p[2:-1, 1:-2, 2:-1] - p[1:-2, 1:-2, 2:-1]) / dx \
        + (p[2:-1, 2:-1, 2:-1] - p[1:-2, 2:-1, 2:-1]) / dx
    )
    p_y = 1. / 4. * (
        (p[1:-2, 2:-1, 1:-2] - p[1:-2, 1:-2, 1:-2]) / dy \
        + (p[2:-1, 2:-1, 1:-2] - p[2:-1, 1:-2, 1:-2]) / dy \
        + (p[1:-2, 2:-1, 2:-1] - p[1:-2, 1:-2, 2:-1]) / dy \
        + (p[2:-1, 2:-1, 2:-1] - p[2:-1, 1:-2, 2:-1]) / dy
    )
    p_z = 1. / 4. * (
        (p[1:-2, 1:-2, 2:-1] - p[1:-2, 1:-2, 1:-2]) / dz \
        + (p[2:-1, 1:-2, 2:-1] - p[2:-1, 1:-2, 1:-2]) / dz \
        + (p[1:-2, 2:-1, 2:-1] - p[1:-2, 2:-1, 1:-2]) / dz \
        + (p[2:-1, 2:-1, 2:-1] - p[2:-1, 2:-1, 1:-2]) / dz
    )
    return p_x, p_y, p_z


def vorticity(u, v, w, dx, dy, dz):
    """
    vorticity of velocity field
    evaluate at cell center
    """
    vor_x = (w[1:-1, 2:, 1:-1] - w[1:-1, :-2, 1:-1]) / (2. * dy) \
            - (v[1:-1, 1:-1, 2:] - v[1:-1, 1:-1, :-2]) / (2. * dz)
    vor_y = (u[1:-1, 1:-1, 2:] - u[1:-1, 1:-1, :-2]) / (2. * dz) \
            - (w[2:, 1:-1, 1:-1] - w[:-2, 1:-1, 1:-1]) / (2. * dx)
    vor_z = (v[2:, 1:-1, 1:-1] - v[:-2, 1:-1, 1:-1]) / (2. * dx) \
            - (u[1:-1, 2:, 1:-1] - u[1:-1, :-2, 1:-1]) / (2. * dy)
    return vor_x, vor_y, vor_z
